<!DOCTYPE html>
<html>
<head>
    <title>Trace Cache论文阅读笔记 - HTML版</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
        h3 { color: #333; border-bottom: 1px solid #e0e0e0; padding-bottom: 5px; }
        table { border-collapse: collapse; width: 100%; margin: 15px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f4f4f4; }
        pre { border: 1px solid #e1e4e8; padding: 10px; background-color: #f6f8fa; margin: 10px 0; }
        .formula { font-family: monospace; background-color: #f0f0f0; padding: 5px; display: inline-block; }
        .highlight { color: #e74c3c; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Trace Cache论文阅读笔记</h1>

    <h3>1. 核心概念与问题</h3>
    <p>**问题背景**：<br>
    <span class="highlight">带宽不足</span>：超标量处理器因分支密集，传统指令缓存无法单周期获取多个非连续基本块。<br>
    <span class="highlight">延迟瓶颈</span>：分支预测错误或缓存缺失时，传统机制需重新获取指令，导致流水线停顿。<br>
    <span class="highlight">分支预测限制</span>：单分支预测/周期的吞吐量不足，无法支持高发射宽度（>4条/cycle）。<br>
    **核心思想**：<br>
    动态轨迹缓存（Trace Cache）缓存动态指令流的执行路径（trace），合并非连续基本块为连续指令，减少带宽与延迟。</p>

    <h3>2. Trace Cache结构与工作流程</h3>
    <pre class="mermaid">
    graph TD  
        A[当前指令地址] --> B[Trace Cache访问]  
        B -->|命中| C[返回Trace Line]  
        C --> D[解码与执行]  
        B -->|未命中| E[核心指令缓存]  
        E --> F[线填充（Line-Fill）逻辑]  
        F --> G[合并非连续指令] --> H[写入Trace Cache]  
        A --> I[分支预测器]  
        I --> B[分支路径标志]  
        style B stroke:#0058a0,stroke-width:2px  
        style C stroke:#4CAF50,stroke-width:2px  
        style E stroke:#e91e63,stroke-width:2px  
    </pre>

    <h3>3. 与传统机制的对比</h3>
    <table>
        <tr><th>方案</th><th>优势</th><th>劣势</th></tr>
        <tr>
            <td>Trace Cache</td>
            <td>低延迟，直接缓存路径，无需重组</td>
            <td>直接映射冲突（trace miss rate≈34%）</td>
        </tr>
        <tr>
            <td>Branch Address Cache</td>
            <td>多分支预测灵活，缓存控制流图分支路径</td>
            <td>需多级缓存，存在缓存冲突与对齐开销</td>
        </tr>
        <tr>
            <td>Collapsing Buffer</td>
            <td>通过合并指令支持短跳转</td>
            <td>多阶段流水线，延迟高（3 cycle）</td>
        </tr>
    </table>

    <h3>4. 性能验证与数据</h3>
    <pre class="mermaid">
    pie  
        title Fetch Latency对SPEC92的性能影响（SEQ.3基准）
        "TC（1 cycle延迟）" : 15  
        "BAC（2 cycles）" : -10  
        "Collapsing Buffer（3 cycles）" : -5  
    </pre>

    <h3>5. 待解决问题与改进建议</h3>
    <pre class="mermaid">
    graph LR  
        A[路径关联（Path Associativity）] --> B{减少冲突丢失}  
        C[部分命中机制（Partial Match）] --> B  
        D[间接跳转预测扩展] --> E[支持复杂控制流]  
        F[Victim Cache] --> G[保留高复用Trace]  
        H[硬件功耗/面积分析] --> I[优化实际实现]  
    </pre>

    <h3>6. 关键公式与数据</h3>
    <div class="formula">  
        Trace Miss Rate = <span style="text-decoration: overline;">Trace Cache Misses</span>  
                       / <span style="text-decoration: overline;">Total Accesses</span>  
    </div>  
    <p>示例：4KB Trace Cache的trace miss rate为34%（表3）</p>

    <div class="formula">  
        IPC提升 = (TC IPC - Base IPC) / Base IPC × 100%  
    </div>

</body>
</html>
